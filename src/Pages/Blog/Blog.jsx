import { Helmet } from "react-helmet-async";
import { FaCircle } from "react-icons/fa6";
import blogImg1 from "/images/blog1.png";
import blogImg2 from "/images/blog2.png";
import blogImg3 from "/images/blog3.png";
import blogImg4 from "/images/blog4.png"



const Blog = () => {
    return (
        <div className="container px-20 mx-auto my-10 flex flex-col items-center w-3/5">
            <Helmet>
                <title>JobVista | Blog</title>
            </Helmet>
            <div className="flex flex-col items-center justify-center">
                <div>
                    <h1 className="text-4xl font-semibold mt-10">
                        Token Talk: Understanding Access and Refresh Tokens in Modern Web Development
                    </h1>
                    <div className="flex flex-col">
                        <p className="mt-5 font-semibold text-gray-500">Author: Jaheda Sultana </p>
                        <div className="flex items-center">
                            <p className="text-sm mr-2 text-gray-500 mt-2">
                                10 min read </p>
                            <p className="text-sm flex items-center gap-2 text-gray-500 mt-2"> <FaCircle size={6} />
                                April 30, 2024 </p>
                        </div>
                    </div>


                </div>
                <img src="https://www.onelogin.com/blog/wp-content/uploads/2023/05/advanced-authentication-blog-image.jpg.optimal.jpg" alt="" className="rounded-md  my-10 " />
            </div>

            <div className="">
                <p className="text-lg">
                    Authentication and authorization form the cornerstone of web security, ensuring that only authorized users can access protected resources. In today's interconnected digital landscape, understanding the nuances of authentication mechanisms is paramount for developers and businesses alike. In this blog post, we delve into the world of token-based authentication, focusing on access tokens, refresh tokens, and best practices for secure token management. We'll unravel the complexities surrounding these tokens, shedding light on how they work and where they should be stored in client-side applications.
                </p>
            </div>
            <div className="my-8">
                <h2 className="text-xl font-bold mb-2">What is Access Token?</h2>
                <p className="text-lg">
                    Access tokens play a pivotal role in modern authentication systems, serving as digital keys that grant users access to protected resources on a server. These resources can range from user data and API endpoints to sensitive information stored in databases.
                </p>
                <h3 className="text-lg font-bold mt-4 mb-2">Granting Access:</h3>
                <p className="text-lg">
                    When a user successfully authenticates themselves to a server, they are issued an access token. This token acts as a credential, proving the user's identity and granting them permission to access specific resources based on their assigned permissions.
                </p>
                <h3 className="text-lg font-bold mt-4 mb-2">Structure of an Access Token:</h3>
                <p className="text-lg">
                    Access tokens typically follow a structured format, with JSON Web Tokens (JWT) being one of the most commonly used formats. A JWT comprises three distinct parts: the header, payload, and signature.
                </p>
                <ol className="text-lg mt-3 px-3 space-y-3">
                    <li><b>Header:</b> The header contains metadata about the token, such as the type of token and the hashing algorithm used to secure it.</li>
                    <li><b>Payload:</b> The payload holds claims or statements about the user, including their identity, roles, and any additional attributes relevant to the application.</li>
                    <li><b>Signature:</b> The signature is a cryptographic hash generated by combining the header, payload, and a secret key known only to the server. It ensures the integrity and authenticity of the token.</li>
                </ol>
                <div>
                    <img src="https://miro.medium.com/v2/resize:fit:1200/1*u3a-5xZDeudKrFGcxHzLew.png" alt="" className="mt-10" />
                    <p className="text-center mt-8 text-sm font-semibold text-slate-500">Structure of an access token</p>
                </div>
                <p className="text-lg mt-10">
                    Once issued, access tokens are included in the headers or payloads of HTTP requests made by the client to access protected resources on the server. The server verifies the token's authenticity and validity before granting access to the requested resource.</p>


            </div>

            <div className="my-4">
                <h2 className="text-xl font-bold mb-2">What is Refresh Token?</h2>
                <p className="text-lg">
                    A refresh token is a long-lived token used in token-based authentication systems alongside access tokens. Unlike access tokens, which have a short lifespan and are used to access protected resources, refresh tokens have a longer lifespan and are used to obtain new access tokens without requiring the user to reauthenticate.
                </p>
                <ol className="text-lg mt-3 px-3 space-y-3">
                    <li><b>Long-term Access:</b>Refresh tokens provides long-term access to a users account without requiring frequent authentication</li>
                    <li><b>Obtaining New Access Tokens: </b> When an access token expires (due to time-based expiration or other factors), the client can use the refresh token to request a new access token from the authorization server.</li>
                    <li><b>Enhanced Security:</b> Refresh tokens mitigate security risks associated with long-lived access tokens. Since access tokens have a short lifespan, the potential impact of token leakage or unauthorized access is limited. Refresh tokens, on the other hand, can be revoked or invalidated if compromised, reducing the window of opportunity for attackers.</li>
                </ol>
            </div>

            <div className="my-4">
                <h2 className="text-xl font-bold mb-2">How do the tokens work together?</h2>
                <p className="text-lg">
                    Access tokens and refresh tokens work in tandem to facilitate secure authentication and access management in token-based authentication systems. When a user logs in, the server issues both an access token and a refresh token. The access token grants short-term access to protected resources, while the refresh token has a longer lifespan and is used to obtain new access tokens without requiring the user to reauthenticate.
                    <p className="text-lg mt-3">Clients include the access token in HTTP requests to access protected resources, and servers validate these tokens to ensure authorized access. When the access token expires, the client uses the refresh token to request a new access token from the authorization server. This process enhances security by limiting the lifespan of access tokens and providing a mechanism for obtaining new tokens seamlessly. By separating access and refresh tokens, the system balances security and usability, minimizing the risk of unauthorized access while ensuring a smooth user experience.</p>
                </p>
            </div>

            <div className="my-4">
                <h2 className="text-xl font-bold mb-2">Storing token in the client side</h2>
                <p className="text-lg">
                    Storing access and refresh tokens on the client-side requires careful consideration of security and usability. Options include localStorage, sessionStorage, cookies, and in-memory storage. localStorage and sessionStorage offer persistence across sessions but may be vulnerable to cross-site scripting (XSS) attacks.
                    <p className="text-lg mt-3">Cookies provide automatic token storage and can be configured with secure flags, but they are susceptible to CSRF attacks and have size limitations. In-memory storage is secure but transient, suitable for sensitive data that doesn't require persistence. Best practices involve encrypting tokens before storage, setting appropriate expiration times, and using HTTPS to protect data in transit. Consider the trade-offs between security, usability, and regulatory compliance when choosing a storage mechanism.</p>
                </p>
            </div>

            <div className="my-4">
                <h2 className="text-xl font-bold mb-2">What is Express.js?</h2>
                <p className="text-lg">
                    Express.js is a widely-used Node.js web application framework known for its minimalistic design and flexibility. It simplifies the process of building web servers and APIs by providing a robust set of features, including routing, middleware support, and streamlined HTTP request/response handling. With Express.js, developers can quickly create scalable and efficient server-side applications, making it an ideal choice for building both small projects and large-scale applications.</p>

                <h2 className="text-xl font-bold mb-2 mt-6">What is Nest.js?</h2>
                <p className="text-lg mt-3">
                    Nest.js is a progressive Node.js framework designed to facilitate the creation of highly efficient and reliable server-side applications. Built with TypeScript and inspired by Angular, Nest.js offers a modular and scalable architecture that promotes code reusability and maintainability. Its dependency injection system and built-in support for TypeScript enable developers to write clean, structured code that is easy to test and maintain. Nest.js is particularly well-suited for building enterprise-grade applications that require robust features and scalability.</p>

            </div>

            <div className="my-6">
                <h2 className="text-xl font-bold mb-2">Explanation with code</h2>
                <p className="text-lg mb-3"> A simple explanation is given below with some sample code in Express.js application that serves as a backend API for a job listing platform.
                </p>
                <img src={blogImg1} alt="" />
                <p className="text-lg my-5"> The above picture shows some dependencies which were required when the project initialized.
                </p>
                <img src={blogImg2} alt="" />
                <p className="text-lg my-5"> This section indicates initialization of the Express application instance(app). Here, cors configuration settings are done to allow requests from the specified origins with credentials. Uses middleware to parse incoming request bodies as JSON and to parse cookies. Besides, establishes a connection to MongoDB database.
                </p>
                <p className="text-lg my-5"> This section indicates initialization of the Express application instance(app). Here, cors configuration settings are done to allow requests from the specified origins with credentials. Uses middleware to parse incoming request bodies as JSON and to parse cookies. Besides, establishes a connection to MongoDB database.
                </p>
                <img src={blogImg3} alt="" />
                <p className="text-lg my-5"> VerifyToken this middleware function is used to authenticate requests by verifying the JWT stored in a cookie. This verifies the JWT using the secret key (process.env.ACCESS_TOKEN_SECRET). If the token is valid, sets the decoded user object on the request (req.user), allowing subsequent route handlers to access the authenticated user's information.
                </p>
                <img src={blogImg4} alt="" />
                <p className="text-lg my-5"> VerifyToken this middleware function is used to authenticate requests by verifying the JWT stored in a cookie. This verifies the JWT using the secret key (process.env.ACCESS_TOKEN_SECRET). If the token is valid, sets the decoded user object on the request (req.user), allowing subsequent route handlers to access the authenticated user's information.
                </p>



            </div>

        </div>
    );
};

export default Blog;